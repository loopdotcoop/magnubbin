<!DOCTYPE html>
<html lang="en">
<head>
  <title>index.html</title>
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8">
  <meta name="generator" content="Apage 0.0.22 http://apage.richplastow.com/">
  <style>
    /* ‘Inspect Element’ here, for Apage’s injected CSS */
  </style>

  <script>

//// When the DOM is ready, set up Apage and inject the plugins. 
window.addEventListener('load', function () { (function (d) { 'use strict'; 


//// Declare iterator, length and HTML-reference variables. 
var i, l, $ref


//// Initialize three arrays which are available to all Apage plugins. 
 ,arts      = []
 ,resolvers = []
 ,updaters  = []


//// Like jQuery, but native. 
 ,$  = d.querySelector.bind(d)
 ,$$ = d.querySelectorAll.bind(d)


//// Get a reference to all `<article class="apage">` elements. 
 ,$arts = $$('article.apage')


//// Convert JavaScript’s native `arguments` object to an array. 
 ,getArgs = function (args, offset) {
    return Array.prototype.slice.call(args, offset || 0);
 }


//// `unattribute($ref,'data-apage-','opath'...)` removes data attributes. 
 ,unattribute = function ($ref, prefix) {
    for ( var i=0, suffs=getArgs(arguments,2), l=suffs.length; i<l; i++ ) {
      $ref.removeAttribute(prefix + suffs[i]);
    }
  }


//// Runs each resolver in order. These are added by the plugins, below. 
//// Resolvers are used to map a query to an article. 
 ,resolve = function (query) {
    for (var i=0, l=resolvers.length, backstop, result={}; i<l; i++) {
      result = resolvers[i](query);
      if (result.art) { break; } // `query` does resolve to an article
      backstop = result.backstop || backstop; // may return a backstop
    }
    return result.art ? result.art : backstop; //@todo test logic of 'last valid backstop return' with several plugins at once
  }


//// Runs each updater in order. These are added by the plugins, below. 
//// Updaters change the current DOM state, eg to show a single article. 
 ,update = function (query) {
    for (var i=0, l=updaters.length, current=resolve(query); i<l; i++) {
      updaters[i](current);
    }
  }


//// Tidies the URL hash and runs `update()` when the URL hash changes. 
 ,onHashchange = function (event) {
    update( window.location.hash.substr(1).replace(/\//g,'_') );
    if (event) { event.preventDefault(); }
  }

;


//// Populate the `arts` array using data from Apage `<ARTICLE>` elements. 
//// Then, remove all 'data-apage-*' attributes except 'data-apage-dname'. 
for (i=0, l=$arts.length; i<l; i++) {
  $ref = $arts[i];
  arts.push({
    id:    $ref.getAttribute('id')
   ,opath: $ref.getAttribute('data-apage-opath')
   ,dname: $ref.getAttribute('data-apage-dname')
   ,order: $ref.getAttribute('data-apage-order')
   ,front: JSON.parse( $ref.getAttribute('data-apage-front') )
   ,title: $ref.getAttribute('data-apage-title')
   ,$ref:  $ref
  });
  unattribute($ref,'data-apage-','opath','order','front','title');
}


//// Begin injecting plugins. 

// Generated by CoffeeScript 1.9.2

/*! Apage 0.0.22 //// MIT Licence //// http://apage.richplastow.com/
 *  plugin/cross-browser.litcoffee
 */

(function() {
  $('style').innerHTML += "\n/* injected by Apage’s CrossBrowser plugin, and adapted from: */\n/* normalize.css v3.0.3 | MIT License | github.com/necolas/normalize.css */\n\n/* Document */\nhtml { font-family:sans-serif; -ms-text-size-adjust:100%; -webkit-text-size-adjust:100% }\nbody { margin:0 }\n\n/* HTML5 */\narticle,aside,details,figcaption,figure,footer,header,hgroup,main,menu,nav,\nsection,summary { display:block }\naudio,canvas,progress,video { display:inline-block; vertical-align:baseline }\naudio:not([controls]) { display:none; height:0 }\n[hidden],template { display:none }\n\n/* Links */\na { background-color:transparent }\na:active,a:hover { outline:0 }\n\n/* Text */\nabbr[title] { border-bottom:1px dotted }\nb, strong { font-weight:bold }\ndfn { font-style:italic }\nh1 { font-size:2em; margin:0.67em 0 }\nmark { background:#ff0; color:#000 }\nsmall { font-size:80% }\nsub,sup { font-size:75%; line-height:0; position:relative; vertical-align:baseline }\nsup { top:-0.5em }\nsub { bottom:-0.25em }\n\n/* Embedded */\nimg { border:0 }\nsvg:not(:root) { overflow:hidden }\n\n/* Grouping */\nfigure { margin:1em 40px }\nhr { box-sizing:content-box; height:0 }\npre { overflow:auto }\ncode,kbd,pre,samp { font-family:monospace,monospace; font-size:1em }\n\n/* Forms */\nbutton,input,optgroup,select,textarea { color:inherit; font:inherit; margin:0 }\nbutton { overflow:visible }\nbutton,select { text-transform:none }\nbutton,html input[type=\"button\"],input[type=\"reset\"],\ninput[type=\"submit\"] { -webkit-appearance:button; cursor:pointer }\nbutton[disabled],html input[disabled] { cursor:default }\nbutton::-moz-focus-inner,input::-moz-focus-inner{ border:0; padding:0 }\ninput { line-height:normal }\ninput[type=\"checkbox\"],input[type=\"radio\"] { box-sizing:border-box; padding:0 }\ninput[type=\"number\"]::-webkit-inner-spin-button,\ninput[type=\"number\"]::-webkit-outer-spin-button { height:auto }\ninput[type=\"search\"] { -webkit-appearance:textfield; box-sizing:content-box }\ninput[type=\"search\"]::-webkit-search-cancel-button,\ninput[type=\"search\"]::-webkit-search-decoration { -webkit-appearance:none }\nfieldset { border:1px solid #c0c0c0; margin:0 2px; padding:0.35em 0.625em 0.75em }\nlegend { border:0; padding:0 }\ntextarea { overflow:auto }\noptgroup { font-weight:bold }\n\n/* Tables */\ntable { border-collapse:collapse; border-spacing:0 }\ntd,th { padding:0 }\n";

}).call(this);
// Generated by CoffeeScript 1.9.2

/*! Apage 0.0.22 //// MIT Licence //// http://apage.richplastow.com/
 *  plugin/pagination.litcoffee
 */

(function() {
  var $ref, art, i, len;

  $('style').innerHTML += "\n/* injected by Apage’s Pagination plugin */\narticle { display: none; }\narticle.active { display: block; }";

  $ref = document.createElement('article');

  $ref.setAttribute('class', 'apage');

  $ref.setAttribute('id', 'apage_undefined');

  $ref.innerHTML = "<!-- injected by Apage’s Pagination plugin -->\n<h1>Article Not Found</h1>";

  d.body.appendChild($ref);

  arts.push({
    id: 'undefined',
    opath: '',
    dname: '',
    order: 0,
    front: [],
    title: 'Article Not Found',
    $ref: $ref
  });

  for (i = 0, len = arts.length; i < len; i++) {
    art = arts[i];
    arts[art.id] = art;
  }

  arts['_'] = arts[0] || arts.undefined;

  resolvers.push(function(query) {
    if (!query) {
      return {
        art: arts[0]
      };
    }
    if (arts[query]) {
      return {
        art: arts[query]
      };
    }
    query = 'apage' + query;
    if (arts[query]) {
      return {
        art: arts[query]
      };
    }
    return {
      backstop: arts.undefined
    };
  });

  updaters.push(function(current) {
    var j, len1;
    for (j = 0, len1 = arts.length; j < len1; j++) {
      art = arts[j];
      art.$ref.className = art.$ref.className.replace(/\s*active|\s*$/g, '');
    }
    current.$ref.className += ' active';
    return d.title = current.title;
  });

}).call(this);
// Generated by CoffeeScript 1.9.2

/*! Ookonsole 0.0.7 //// MIT Licence //// http://ookonsole.richplastow.com/ */

(function() {
  var Main, Task, zz, ª, ªA, ªB, ªC, ªE, ªF, ªN, ªO, ªR, ªS, ªU, ªV, ªX, ªcommonPrefix, ªex, ªhas, ªredefine, ªtype, ªuid,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  ªC = 'Ookonsole';

  ªV = '0.0.7';

  ªA = 'array';

  ªB = 'boolean';

  ªE = 'error';

  ªF = 'function';

  ªN = 'number';

  ªO = 'object';

  ªR = 'regexp';

  ªS = 'string';

  ªU = 'undefined';

  ªX = this;

  ª = console.log.bind(console);

  ªex = function(x, a, b) {
    var pos;
    if (-1 === (pos = a.indexOf(x))) {
      return x;
    } else {
      return b.charAt(pos);
    }
  };

  ªhas = function(h, n, t, f) {
    if (t == null) {
      t = true;
    }
    if (f == null) {
      f = false;
    }
    if (-1 !== h.indexOf(n)) {
      return t;
    } else {
      return f;
    }
  };

  ªtype = function(x) {
    return {}.toString.call(x).match(/\s([a-z|A-Z]+)/)[1].toLowerCase();
  };

  ªuid = function(p) {
    return p + '_' + (Math.random() + '1111111111111111').slice(2, 18);
  };

  ªcommonPrefix = function(strings) {
    var a, first, i, l, last;
    a = strings.concat().sort();
    first = a[0];
    last = a[a.length - 1];
    l = first.length;
    i = 0;
    while (i < l && first.charAt(i) === last.charAt(i)) {
      i++;
    }
    return first.slice(0, i);
  };

  ªredefine = function(obj, name, value, kind) {
    switch (kind) {
      case 'constant':
        return Object.defineProperty(obj, name, {
          value: value,
          enumerable: true
        });
      case 'private':
        return Object.defineProperty(obj, name, {
          value: value,
          enumerable: false
        });
    }
  };

  Main = (function() {
    Main.prototype.C = ªC;

    Main.prototype.toString = function() {
      return "[object " + this.C + "]";
    };

    function Main(config) {
      if (config == null) {
        config = {};
      }
      this.onKeydown = bind(this.onKeydown, this);
      this.addTask = bind(this.addTask, this);
      this.context = config.context || null;
      if (ªO !== typeof this.context) {
        throw Error("`config.context` is type " + (typeof this.context) + " not 'object'");
      }
      this.unrecognized = new Task({
        summary: "Used when the requested task does not exist",
        completions: [],
        details: "This task is not used directly",
        runner: function(context, options) {
          return "That task does not exist: type `help` to list commands";
        }
      });
      this.tasks = {
        help: new Task({
          summary: "Show this help. Type `help help` for more details",
          completions: ['help '],
          details: "help\n----\nA built-in ookonsole task, which shows helpful usage information. \n\nhelp         With no options, lists and summarizes all available tasks\nhelp <task>  Shows details about the given task, eg `help clear`, to \n             display details on `clear` and its options\n",
          runner: (function(_this) {
            return function(context, options) {
              var name, task;
              switch (options.length) {
                case 0:
                  return ((function() {
                    var ref, results;
                    ref = this.tasks;
                    results = [];
                    for (name in ref) {
                      task = ref[name];
                      results.push(name + ": " + task.summary);
                    }
                    return results;
                  }).call(_this)).join('\n');
                case 1:
                  if (_this.tasks[options[0]]) {
                    return _this.tasks[options[0]].details;
                  } else {
                    return "That task does not exist: type `help` to list commands";
                  }
                  break;
                default:
                  return "Too many options: try `help " + options[0] + "`";
              }
            };
          })(this)
        }),
        clear: new Task({
          summary: "Delete the contents of the log",
          completions: ['clear display', 'clear storage', 'clear all'],
          details: "clear\n-----\nA built-in ookonsole task, which shows helpful usage information. \n\nclear display  Clears the log display, but leaves the in-storage log intact\nclear storage  Deletes localStorage (browser) or filesystem (server) logs\nclear all      Both of the above\nclear          With no options, runs `clear display`\n",
          runner: (function(_this) {
            return function(context, options) {
              switch (options.length) {
                case 0:
                  _this.$display.innerHTML = '';
                  return false;
                case 1:
                  if ('display' === options[0]) {
                    return _this.tasks.clear.runner(context, []);
                  } else {
                    return "@todo";
                  }
                  break;
                default:
                  return "Too many options: try `clear " + options[0] + "`";
              }
            };
          })(this)
        })
      };
      if (ªU === ªtype(config.$wrap)) {
        this.$wrap = null;
      } else if (config.$wrap instanceof ªX.HTMLElement) {
        this.$wrap = config.$wrap;
      } else {
        throw Error("`config.$wrap` is not an instance of `HTMLElement`");
      }
      if (!this.$wrap) {
        this.$style = null;
      } else {
        this.$style = ªX.document.createElement('style');
        this.$style.innerHTML = this.getStyle();
      }
      if (!this.$wrap) {
        this.$box = null;
      } else {
        this.$box = ªX.document.createElement('div');
        this.$box.setAttribute('class', 'ookonsole-box');
      }
      if (!this.$wrap) {
        this.$display = config.$display || null;
      } else {
        this.$display = ªX.document.createElement('pre');
        this.$display.setAttribute('class', 'ookonsole-display');
        this.$box.appendChild(this.$display);
      }
      if (!this.$wrap) {
        this.$command = config.$command || null;
      } else {
        this.$command = ªX.document.createElement('input');
        this.$command.setAttribute('class', 'ookonsole-command');
        this.$box.appendChild(this.$command);
      }
      this.pointer = null;
    }

    Main.prototype.show = function() {
      var ref, ref1;
      if ((ref = this.$wrap) != null) {
        ref.appendChild(this.$style);
      }
      return (ref1 = this.$wrap) != null ? ref1.appendChild(this.$box) : void 0;
    };

    Main.prototype.hide = function() {
      var ref, ref1;
      if ((ref = this.$wrap) != null) {
        ref.removeChild(this.$style);
      }
      return (ref1 = this.$wrap) != null ? ref1.removeChild(this.$box) : void 0;
    };

    Main.prototype.start = function() {
      var ref, ref1;
      if ((ref = this.$command) != null) {
        ref.focus();
      }
      return (ref1 = this.$command) != null ? ref1.addEventListener('keydown', this.onKeydown) : void 0;
    };

    Main.prototype.stop = function() {
      return ª(456);
    };

    Main.prototype.addTask = function(name, config) {
      return this.tasks[name] = new Task(config);
    };

    Main.prototype.onKeydown = function(event) {
      var log, nextCommandEnd, nextCommandStart, prevCommandEnd, prevCommandStart;
      switch (event.keyCode) {
        case 13:
          return this.execute(this.$command.value);
        case 9:
          this.autocomplete(this.$command.value);
          return event.preventDefault();
        case 38:
          log = this.$display.innerHTML;
          this.pointer = null === this.pointer ? log.length : this.pointer;
          prevCommandStart = log.lastIndexOf('§ ', this.pointer);
          if (-1 === prevCommandStart) {
            return;
          }
          prevCommandEnd = log.indexOf('\n', prevCommandStart);
          if (-1 === prevCommandEnd) {
            return;
          }
          this.pointer = prevCommandStart - 1;
          this.$command.value = log.slice(prevCommandStart + 2, prevCommandEnd);
          return event.preventDefault();
        case 40:
          log = this.$display.innerHTML;
          this.pointer = null === this.pointer ? log.length : this.pointer + 2;
          nextCommandStart = log.indexOf('§ ', this.pointer);
          if (-1 === nextCommandStart) {
            return;
          }
          nextCommandEnd = log.indexOf('\n', nextCommandStart);
          if (-1 === nextCommandEnd) {
            return;
          }
          this.pointer = nextCommandStart;
          return this.$command.value = log.slice(nextCommandStart + 2, nextCommandEnd);
      }
    };

    Main.prototype.autocomplete = function(command) {
      var candidates, completion, j, len, name, ref, ref1, task;
      candidates = [];
      ref = this.tasks;
      for (name in ref) {
        task = ref[name];
        ref1 = task.completions;
        for (j = 0, len = ref1.length; j < len; j++) {
          completion = ref1[j];
          if ((completion.slice(0, command.length)) === command) {
            candidates.push(completion);
          }
        }
      }
      if (1 === candidates.length) {
        return this.$command.value = candidates[0];
      } else if (0 !== candidates.length) {
        return this.$command.value = ªcommonPrefix(candidates);
      }
    };

    Main.prototype.execute = function(command) {
      var hasScrolledToEnd, i, options, result, task;
      this.pointer = null;
      hasScrolledToEnd = this.$display.scrollTop > this.$display.scrollHeight - this.$display.offsetHeight;
      this.$display.innerHTML += "§ " + command + "\n";
      this.$command.value = '';
      options = command.split(' ');
      i = options.length;
      while (0 < i--) {
        if ('' === options[i]) {
          options.splice(i, 1);
        }
      }
      if (options.length) {
        task = this.tasks[options.shift()];
      } else {
        return;
      }
      if (!task) {
        task = this.unrecognized;
      }
      result = task.runner(this.context, options);
      if (false !== result) {
        this.$display.innerHTML += (result.replace(/</g, '&lt;')) + '\n';
      }
      if (hasScrolledToEnd) {
        return this.$display.scrollTop = this.$display.scrollHeight;
      }
    };

    Main.prototype.getStyle = function() {
      return ".ookonsole-box {\n  padding:    0.5rem;\n  border:     1px solid #999;\n}\n.ookonsole-display {\n  margin:     0;\n  padding:    0.5rem;\n  border:     1px solid #999;\n  font:       1rem/1.3rem monaco, monospace;\n}\n.ookonsole-command {\n  display:    block;\n  box-sizing: border-box;\n  width:      100%;\n  padding:    0.5rem;\n  border:     1px solid #999;\n  font:       1rem/1.3rem monaco, monospace;\n}";
    };

    return Main;

  })();

  zz = function(xx) {};

  Task = (function() {
    Task.prototype.C = 'Task';

    Task.prototype.toString = function() {
      return "[object " + this.C + "]";
    };

    function Task(config) {
      var completion, j, len, ref;
      if (config == null) {
        config = {};
      }
      this.summary = config.summary;
      if (ªS !== ªtype(this.summary)) {
        throw Error("`config.summary` is '" + (ªtype(this.summary)) + "' not 'string'");
      }
      this.completions = config.completions;
      if (ªA !== ªtype(this.completions)) {
        throw Error("`config.completions` is '" + (ªtype(this.completions)) + "' not 'array'");
      }
      ref = this.completions;
      for (j = 0, len = ref.length; j < len; j++) {
        completion = ref[j];
        if (ªS !== ªtype(completion)) {
          throw Error("`config.completions` contains '" + (ªtype(completion)) + "' not 'string'");
        }
      }
      this.details = config.details;
      if (ªS !== ªtype(this.details)) {
        throw Error("`config.details` is '" + (ªtype(this.details)) + "' not 'string'");
      }
      this.runner = config.runner;
      if (ªF !== ªtype(this.runner)) {
        throw Error("`config.runner` is '" + (ªtype(this.runner)) + "' not 'function'");
      }
    }

    Task.prototype.run = function() {
      return this.runner.apply(context, options);
    };

    return Task;

  })();

  if (ªF === typeof define && define.amd) {
    define(function() {
      return Main;
    });
  } else if (ªO === typeof module && module && module.exports) {
    module.exports = Main;
  } else {
    this[ªC] = Main;
  }

}).call(this);
// Generated by CoffeeScript 1.9.2

/*! Oo3d 0.0.16 //// MIT Licence //// http://oo3d.richplastow.com/ */

(function() {
  var Buffer, Camera, Main, getFragmentSource, getVertexSource, mat4, ª, ªA, ªB, ªC, ªE, ªF, ªN, ªO, ªR, ªS, ªU, ªV, ªW, ªX, ªex, ªhas, ªisU, ªredefine, ªtype, ªuid;

  ªC = 'Oo3d';

  ªV = '0.0.16';

  ªA = 'array';

  ªB = 'boolean';

  ªE = 'error';

  ªF = 'function';

  ªN = 'number';

  ªO = 'object';

  ªR = 'regexp';

  ªS = 'string';

  ªU = 'undefined';

  ªX = 'null';

  ªW = this;

  ª = console.log.bind(console);

  ªex = function(x, a, b) {
    var pos;
    if (-1 === (pos = a.indexOf(x))) {
      return x;
    } else {
      return b.charAt(pos);
    }
  };

  ªhas = function(h, n, t, f) {
    if (t == null) {
      t = true;
    }
    if (f == null) {
      f = false;
    }
    if (-1 !== h.indexOf(n)) {
      return t;
    } else {
      return f;
    }
  };

  ªtype = function(x) {
    return {}.toString.call(x).match(/\s([a-z|A-Z]+)/)[1].toLowerCase();
  };

  ªisU = function(x) {
    return ªU === typeof x;
  };

  ªuid = function(p) {
    return p + '_' + (Math.random() + '1111111111111111').slice(2, 18);
  };

  ªredefine = function(obj, name, value, kind) {
    switch (kind) {
      case 'constant':
        return Object.defineProperty(obj, name, {
          value: value,
          enumerable: true
        });
      case 'private':
        return Object.defineProperty(obj, name, {
          value: value,
          enumerable: false
        });
    }
  };

  Buffer = (function() {
    Buffer.prototype.C = 'Buffer';

    Buffer.prototype.toString = function() {
      return "[object " + this.C + "]";
    };

    function Buffer(config, gl) {
      var i;
      if (config == null) {
        config = {};
      }
      this.gl = gl;
      if ('webglrenderingcontext' !== ªtype(this.gl)) {
        throw Error("gl must be WebGLRenderingContext not " + (ªtype(this.gl)));
      }
      if (ªA !== ªtype(config.positions)) {
        throw Error("config.positions must be an array not " + (ªtype(config.positions)));
      }
      if (config.positions.length % 3) {
        throw Error("config.positions.length must be divisible by 3");
      }
      this.positionBuffer = this.gl.createBuffer();
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.positionBuffer);
      this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(config.positions), this.gl.STATIC_DRAW);
      if (ªU === ªtype(config.colors)) {
        config.colors = (function() {
          var j, ref, results;
          results = [];
          for (i = j = 0, ref = config.positions.length / 3 * 4 - 1; 0 <= ref ? j <= ref : j >= ref; i = 0 <= ref ? ++j : --j) {
            results.push(1);
          }
          return results;
        })();
      } else if (ªA !== ªtype(config.colors)) {
        throw Error("config.colors must be an array not " + (ªtype(config.colors)));
      } else if (config.colors.length % 4) {
        throw Error("config.colors.length must be divisible by 4");
      } else if (config.positions.length / 3 !== config.colors.length / 4) {
        throw Error("config.colors has an incorrect vertex count");
      }
      this.colorBuffer = this.gl.createBuffer();
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.colorBuffer);
      this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(config.colors), this.gl.STATIC_DRAW);
      this.count = config.positions.length / 3;
      this.matTransform = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
      this.rX = 0;
      this.rY = 0;
      this.rZ = 0;
      this.sX = 1;
      this.sY = 1;
      this.sZ = 1;
      this.tX = 0;
      this.tY = 0;
      this.tZ = 0;
      this.renderMode = config.renderMode || 'TRIANGLES';
      if (ªN !== ªtype(this.gl[this.renderMode])) {
        throw Error("`renderMode` " + this.renderMode + " is not recognised by WebGL");
      }
    }

    Buffer.prototype.xx = function() {};

    return Buffer;

  })();

  Camera = (function() {
    Camera.prototype.C = 'Camera';

    Camera.prototype.toString = function() {
      return "[object " + this.C + "]";
    };

    function Camera(scene, config) {
      var k, v;
      if (config == null) {
        config = {};
      }
      for (k in config) {
        v = config[k];
        this[k] = v;
      }
      this.gl = scene.gl;
      if ('webglrenderingcontext' !== ªtype(this.gl)) {
        throw Error("scene.gl must be WebGLRenderingContext not " + (ªtype(this.gl)));
      }
      this.program = scene.program;
      if ('webglprogram' !== ªtype(this.program)) {
        throw Error("scene.program must be WebGLProgram not " + (ªtype(this.program)));
      }
      this.matProjection = mat4.perspective(this.fovy, this.aspect, 1, 100);
      this.matTransform = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, -10, 1]);
      this.matCamera = null;
      this.uMatCameraLoc = this.gl.getUniformLocation(this.program, 'uMatCamera');
      this.rX = 0;
      this.rY = 0;
      this.rZ = 0;
      this.sX = 1;
      this.sY = 1;
      this.sZ = 1;
      this.tX = 0;
      this.tY = 0;
      this.tZ = -10;
      this.updateCamera();
    }

    Camera.prototype.updateCamera = function() {
      this.matCamera = mat4.multiply(this.matProjection, this.matTransform);
      return this.gl.uniformMatrix4fv(this.uMatCameraLoc, false, new Float32Array(this.matCamera));
    };

    Camera.prototype.xx = function() {};

    return Camera;

  })();

  Main = (function() {
    Main.prototype.C = ªC;

    Main.prototype.toString = function() {
      return "[object " + this.C + "]";
    };

    function Main(config) {
      var k, ref, v;
      if (config == null) {
        config = {};
      }
      for (k in config) {
        v = config[k];
        this[k] = v;
      }
      this.$main = config.$main || null;
      if (this.$main && ('htmlcanvaselement' !== ªtype(this.$main))) {
        throw Error("If set, config.$main must be HTMLCanvasElement not " + (ªtype(this.$main)));
      }
      this.gl = null;
      if (ªO === ªtype((ref = config.color) != null ? ref.background : void 0)) {
        this.bkgndR = config.color.background.r;
        this.bkgndG = config.color.background.g;
        this.bkgndB = config.color.background.b;
        this.bkgndA = config.color.background.a;
      } else {
        this.bkgndR = this.bkgndG = this.bkgndB = 0.125;
        this.bkgndA = 1;
      }
      this.vertexShader = null;
      this.fragmentShader = null;
      this.program = null;
      this.aVtxPositionLoc = null;
      this.aVtxColorLoc = null;
      this.buffers = [];
      if (this.$main) {
        this.initGL();
        if (this.gl) {
          this.initCanvas();
          this.initShaders();
          this.initProgram();
          this.camera = new Camera(this, {
            fovy: 0.785398163,
            aspect: this.$main.width / this.$main.height
          });
        }
      }
    }

    Main.prototype.initGL = function() {
      try {
        this.gl = this.$main.getContext('webgl' || this.$main.getContext('experimental-webgl'));
      } catch (_error) {

      }
      if (!this.gl) {
        throw Error("Unable to initialize WebGL. Your browser may not support it.");
      }
    };

    Main.prototype.initCanvas = function() {
      this.gl.clearColor(this.bkgndR, this.bkgndG, this.bkgndB, this.bkgndA);
      this.gl.enable(this.gl.DEPTH_TEST);
      this.gl.depthFunc(this.gl.LEQUAL);
      this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT);
      return this.gl.viewport(0, 0, this.$main.width, this.$main.height);
    };

    Main.prototype.initShaders = function() {
      this.vertexShader = this.gl.createShader(this.gl.VERTEX_SHADER);
      this.fragmentShader = this.gl.createShader(this.gl.FRAGMENT_SHADER);
      this.gl.shaderSource(this.vertexShader, getVertexSource());
      this.gl.shaderSource(this.fragmentShader, getFragmentSource());
      this.gl.compileShader(this.vertexShader);
      this.gl.compileShader(this.fragmentShader);
      if (!this.gl.getShaderParameter(this.vertexShader, this.gl.COMPILE_STATUS)) {
        this.cleanUp();
        throw Error("@vertexShader did not compile successfully");
      }
      if (!this.gl.getShaderParameter(this.fragmentShader, this.gl.COMPILE_STATUS)) {
        this.cleanUp();
        throw Error("@fragmentShader did not compile successfully");
      }
    };

    Main.prototype.initProgram = function() {
      this.program = this.gl.createProgram();
      this.gl.attachShader(this.program, this.vertexShader);
      this.gl.attachShader(this.program, this.fragmentShader);
      this.gl.linkProgram(this.program);
      if (!this.gl.getProgramParameter(this.program, this.gl.LINK_STATUS)) {
        this.cleanUp();
        throw Error("@program did not link successfully");
      }
      this.gl.useProgram(this.program);
      this.aVtxPositionLoc = this.gl.getAttribLocation(this.program, 'aVtxPosition');
      this.aVtxColorLoc = this.gl.getAttribLocation(this.program, 'aVtxColor');
      this.gl.enableVertexAttribArray(this.aVtxPositionLoc);
      this.gl.enableVertexAttribArray(this.aVtxColorLoc);
      return this.uMatTransformLoc = this.gl.getUniformLocation(this.program, 'uMatTransform');
    };

    Main.prototype.cleanUp = function() {
      if (this.vertexShader) {
        this.gl.deleteShader(this.vertexShader);
      }
      if (this.fragmentShader) {
        this.gl.deleteShader(this.fragmentShader);
      }
      if (this.program) {
        return this.gl.deleteProgram(this.program);
      }
    };

    Main.prototype.addBuffer = function(config) {
      var index;
      index = this.buffers.length;
      this.buffers[index] = new Buffer(config, this.gl);
      return index;
    };

    Main.prototype.rotate = function(x, y, z, targetIndex) {
      var c, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, mat, s, target, x0, y0, z0;
      target = this.buffers[targetIndex] || this.camera;
      mat = target.matTransform;
      x0 = 0 === x;
      y0 = 0 === y;
      z0 = 0 === z;
      if (x0 && y0 && z0) {
        return this;
      } else if (y0 && z0) {
        s = Math.sin(x);
        c = Math.cos(x);
        m10 = mat[4];
        m11 = mat[5];
        m12 = mat[6];
        m13 = mat[7];
        m20 = mat[8];
        m21 = mat[9];
        m22 = mat[10];
        m23 = mat[11];
        mat[4] = m10 * c + m20 * s;
        mat[5] = m11 * c + m21 * s;
        mat[6] = m12 * c + m22 * s;
        mat[7] = m13 * c + m23 * s;
        mat[8] = m20 * c - m10 * s;
        mat[9] = m21 * c - m11 * s;
        mat[10] = m22 * c - m12 * s;
        mat[11] = m23 * c - m13 * s;
        target.rX += x;
      } else if (x0 && z0) {
        s = Math.sin(y);
        c = Math.cos(y);
        m00 = mat[0];
        m01 = mat[1];
        m02 = mat[2];
        m03 = mat[3];
        m20 = mat[8];
        m21 = mat[9];
        m22 = mat[10];
        m23 = mat[11];
        mat[0] = m00 * c - m20 * s;
        mat[1] = m01 * c - m21 * s;
        mat[2] = m02 * c - m22 * s;
        mat[3] = m03 * c - m23 * s;
        mat[8] = m00 * s + m20 * c;
        mat[9] = m01 * s + m21 * c;
        mat[10] = m02 * s + m22 * c;
        mat[11] = m03 * s + m23 * c;
        target.rY += y;
      } else if (x0 && y0) {
        s = Math.sin(z);
        c = Math.cos(z);
        m00 = mat[0];
        m01 = mat[1];
        m02 = mat[2];
        m03 = mat[3];
        m10 = mat[4];
        m11 = mat[5];
        m12 = mat[6];
        m13 = mat[7];
        mat[0] = m00 * c + m10 * s;
        mat[1] = m01 * c + m11 * s;
        mat[2] = m02 * c + m12 * s;
        mat[3] = m03 * c + m13 * s;
        mat[4] = m10 * c - m00 * s;
        mat[5] = m11 * c - m01 * s;
        mat[6] = m12 * c - m02 * s;
        mat[7] = m13 * c - m03 * s;
        target.rZ += z;
      } else {
        this.rotate(x, 0, 0, targetIndex);
        this.rotate(0, y, 0, targetIndex);
        this.rotate(0, 0, z, targetIndex);
      }
      if (target === this.camera) {
        this.camera.updateCamera();
      }
      return this;
    };

    Main.prototype.scale = function(x, y, z, targetIndex) {
      var mat, target, x1, y1, z1;
      target = this.buffers[targetIndex] || this.camera;
      mat = target.matTransform;
      x1 = 1 === x;
      y1 = 1 === y;
      z1 = 1 === z;
      if (!x1) {
        mat[0] *= x;
        mat[1] *= x;
        mat[2] *= x;
        mat[3] *= x;
        target.sX *= x;
      }
      if (!y1) {
        mat[4] *= y;
        mat[5] *= y;
        mat[6] *= y;
        mat[7] *= y;
        target.sY *= y;
      }
      if (!z1) {
        mat[8] *= z;
        mat[9] *= z;
        mat[10] *= z;
        mat[11] *= z;
        target.sZ *= z;
      }
      if (target === this.camera) {
        this.camera.updateCamera();
      }
      return this;
    };

    Main.prototype.translate = function(x, y, z, targetIndex) {
      var mat, target, x0, y0, z0;
      target = this.buffers[targetIndex] || this.camera;
      mat = target.matTransform;
      x0 = 0 === x;
      y0 = 0 === y;
      z0 = 0 === z;
      if (x0 && y0 && z0) {
        return this;
      } else if (y0 && z0) {
        mat[12] += mat[0] * x;
        mat[13] += mat[1] * x;
        mat[14] += mat[2] * x;
        mat[15] += mat[3] * x;
        target.tX += x;
      } else if (x0 && z0) {
        mat[12] += mat[4] * y;
        mat[13] += mat[5] * y;
        mat[14] += mat[6] * y;
        mat[15] += mat[7] * y;
        target.tY += y;
      } else if (x0 && y0) {
        mat[12] += mat[8] * z;
        mat[13] += mat[9] * z;
        mat[14] += mat[10] * z;
        mat[15] += mat[11] * z;
        target.tZ += z;
      } else {
        mat[12] += mat[0] * x + mat[4] * y + mat[8] * z;
        mat[13] += mat[1] * x + mat[5] * y + mat[9] * z;
        mat[14] += mat[2] * x + mat[6] * y + mat[10] * z;
        mat[15] += mat[3] * x + mat[7] * y + mat[11] * z;
        target.tX += x;
        target.tY += y;
        target.tZ += z;
      }
      if (target === this.camera) {
        this.camera.updateCamera();
      }
      return this;
    };

    Main.prototype.setRenderMode = function(renderMode, targetIndex) {
      return this.buffers[targetIndex].renderMode = renderMode;
    };

    Main.prototype.render = function() {
      var buffer, index, mode, results;
      if (!this.gl) {
        throw Error("The WebGL rendering context is " + (ªtype(this.gl)));
      }
      this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT);
      index = this.buffers.length;
      results = [];
      while (index--) {
        buffer = this.buffers[index];
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, buffer.positionBuffer);
        this.gl.vertexAttribPointer(this.aVtxPositionLoc, 3, this.gl.FLOAT, false, 0, 0);
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, buffer.colorBuffer);
        this.gl.vertexAttribPointer(this.aVtxColorLoc, 4, this.gl.FLOAT, false, 0, 0);
        this.gl.uniformMatrix4fv(this.uMatTransformLoc, false, new Float32Array(buffer.matTransform));
        mode = this.gl[buffer.renderMode];
        this.gl.drawArrays(mode, 0, buffer.count);
        results.push(this.gl.flush());
      }
      return results;
    };

    return Main;

  })();

  getVertexSource = function() {
    return "attribute vec3 aVtxPosition;\nattribute vec4 aVtxColor;\n\nuniform mat4 uMatTransform;\nuniform mat4 uMatCamera;\n\nvarying vec4 vColor; // declare `vColor`\n\nvoid main() {\n\n  // Multiply the position by the camera transformation and matrices\n  // Note that the order of these three is important\n  gl_Position = uMatCamera * uMatTransform * vec4(aVtxPosition, 1);\n\n  // Convert from clipspace to colorspace, and send to the fragment-shader\n  // Clipspace goes -1.0 to +1.0\n  // Colorspace goes from 0.0 to 1.0\n  // vColor = gl_Position * 0.5 + 0.5; //vec4(4,4,4,4);\n\n  // Just pass the vertex-color attribute unchanged to the fragment-shader\n  vColor = aVtxColor;\n}";
  };

  getFragmentSource = function() {
    return "precision mediump float; // boilerplate for mobile-friendly shaders\nvarying vec4 vColor;     // linear-interpolated input from fragment-shader\n\nvoid main(void) {\n  gl_FragColor = vColor;\n}";
  };

  if (ªF === typeof define && define.amd) {
    define(function() {
      return Main;
    });
  } else if (ªO === typeof module && module && module.exports) {
    module.exports = Main;
  } else {
    ªW[ªC] = Main;
  }

  mat4 = {};

  mat4.multiply = function(a, b) {
    var a00, a01, a02, a03, a10, a11, a12, a13, a20, a21, a22, a23, a30, a31, a32, a33, b0, b1, b2, b3, out;
    out = new Float32Array(16);
    a00 = a[0];
    a01 = a[1];
    a02 = a[2];
    a03 = a[3];
    a10 = a[4];
    a11 = a[5];
    a12 = a[6];
    a13 = a[7];
    a20 = a[8];
    a21 = a[9];
    a22 = a[10];
    a23 = a[11];
    a30 = a[12];
    a31 = a[13];
    a32 = a[14];
    a33 = a[15];
    b0 = b[0];
    b1 = b[1];
    b2 = b[2];
    b3 = b[3];
    out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = b[4];
    b1 = b[5];
    b2 = b[6];
    b3 = b[7];
    out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = b[8];
    b1 = b[9];
    b2 = b[10];
    b3 = b[11];
    out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = b[12];
    b1 = b[13];
    b2 = b[14];
    b3 = b[15];
    out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    return out;
  };

  mat4.perspective = function(fovy, aspect, near, far) {
    var f, nf, out;
    f = 1.0 / Math.tan(fovy / 2);
    nf = 1 / (near - far);
    out = new Float32Array(16);
    out[0] = f / aspect;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = f;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = (far + near) * nf;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[14] = (2 * far * near) * nf;
    out[15] = 0;
    return out;
  };

  mat4.rotateX = function(a, rad) {
    var a10, a11, a12, a13, a20, a21, a22, a23, c, s;
    s = Math.sin(rad);
    c = Math.cos(rad);
    a10 = a[4];
    a11 = a[5];
    a12 = a[6];
    a13 = a[7];
    a20 = a[8];
    a21 = a[9];
    a22 = a[10];
    a23 = a[11];
    a[4] = a10 * c + a20 * s;
    a[5] = a11 * c + a21 * s;
    a[6] = a12 * c + a22 * s;
    a[7] = a13 * c + a23 * s;
    a[8] = a20 * c - a10 * s;
    a[9] = a21 * c - a11 * s;
    a[10] = a22 * c - a12 * s;
    a[11] = a23 * c - a13 * s;
    return a;
  };

  mat4.rotateY = function(a, rad) {
    var a00, a01, a02, a03, a20, a21, a22, a23, c, s;
    s = Math.sin(rad);
    c = Math.cos(rad);
    a00 = a[0];
    a01 = a[1];
    a02 = a[2];
    a03 = a[3];
    a20 = a[8];
    a21 = a[9];
    a22 = a[10];
    a23 = a[11];
    a[0] = a00 * c - a20 * s;
    a[1] = a01 * c - a21 * s;
    a[2] = a02 * c - a22 * s;
    a[3] = a03 * c - a23 * s;
    a[8] = a00 * s + a20 * c;
    a[9] = a01 * s + a21 * c;
    a[10] = a02 * s + a22 * c;
    a[11] = a03 * s + a23 * c;
    return a;
  };

  mat4.rotateZ = function(a, rad) {
    var a00, a01, a02, a03, a10, a11, a12, a13, c, s;
    s = Math.sin(rad);
    c = Math.cos(rad);
    a00 = a[0];
    a01 = a[1];
    a02 = a[2];
    a03 = a[3];
    a10 = a[4];
    a11 = a[5];
    a12 = a[6];
    a13 = a[7];
    a[0] = a00 * c + a10 * s;
    a[1] = a01 * c + a11 * s;
    a[2] = a02 * c + a12 * s;
    a[3] = a03 * c + a13 * s;
    a[4] = a10 * c - a00 * s;
    a[5] = a11 * c - a01 * s;
    a[6] = a12 * c - a02 * s;
    a[7] = a13 * c - a03 * s;
    return a;
  };

  mat4.translate = function(a, x, y, z) {
    a[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
    a[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
    a[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
    a[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
    return a;
  };

  mat4.ortho = function(left, right, bottom, top, near, far) {
    var bt, lr, nf, out;
    lr = 1 / (left - right);
    bt = 1 / (bottom - top);
    nf = 1 / (near - far);
    out = new Float32Array(16);
    out[0] = -2 * lr;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = -2 * bt;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 2 * nf;
    out[11] = 0;
    out[12] = (left + right) * lr;
    out[13] = (top + bottom) * bt;
    out[14] = (far + near) * nf;
    out[15] = 1;
    return out;
  };

  mat4.makeTranslation = function(tx, ty, tz) {
    return new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, tx, ty, tz, 1]);
  };

  mat4.makeXRotation = function(angleInRadians) {
    var c, s;
    c = Math.cos(angleInRadians);
    s = Math.sin(angleInRadians);
    return new Float32Array([1, 0, 0, 0, 0, c, s, 0, 0, -s, c, 0, 0, 0, 0, 1]);
  };

  mat4.makeYRotation = function(angleInRadians) {
    var c, s;
    c = Math.cos(angleInRadians);
    s = Math.sin(angleInRadians);
    return new Float32Array([c, 0, -s, 0, 0, 1, 0, 0, s, 0, c, 0, 0, 0, 0, 1]);
  };

  mat4.makeZRotation = function(angleInRadians) {
    var c, s;
    c = Math.cos(angleInRadians);
    s = Math.sin(angleInRadians);
    return new Float32Array([c, s, 0, 0, -s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
  };

  mat4.makeScale = function(sx, sy, sz) {
    return new Float32Array([sx, 0, 0, 0, 0, sy, 0, 0, 0, 0, sz, 0, 0, 0, 0, 1]);
  };

  mat4.makeProjection = function(width, height, depth) {
    return new Float32Array([2 / width, 0, 0, 0, 0, -2 / height, 0, 0, 0, 0, 2 / depth, 0, -1, 1, 0, 1]);
  };

}).call(this);
// Generated by CoffeeScript 1.9.2

/*! Magnubbin 0.0.7 //// MIT Licence //// http://magnubbin.loop.coop/ */

(function() {
  var Main, Ookonsole, injectCSS, injectHTML, main, ª, ªA, ªB, ªC, ªE, ªF, ªN, ªO, ªR, ªS, ªU, ªV, ªX, ªex, ªhas, ªredefine, ªtype, ªuid;

  ªC = 'Magnubbin';

  ªV = '0.0.7';

  ªA = 'array';

  ªB = 'boolean';

  ªE = 'error';

  ªF = 'function';

  ªN = 'number';

  ªO = 'object';

  ªR = 'regexp';

  ªS = 'string';

  ªU = 'undefined';

  ªX = this;

  ª = console.log.bind(console);

  ªex = function(x, a, b) {
    var pos;
    if (-1 === (pos = a.indexOf(x))) {
      return x;
    } else {
      return b.charAt(pos);
    }
  };

  ªhas = function(h, n, t, f) {
    if (t == null) {
      t = true;
    }
    if (f == null) {
      f = false;
    }
    if (-1 !== h.indexOf(n)) {
      return t;
    } else {
      return f;
    }
  };

  ªtype = function(x) {
    return {}.toString.call(x).match(/\s([a-z|A-Z]+)/)[1].toLowerCase();
  };

  ªuid = function(p) {
    return p + '_' + (Math.random() + '1111111111111111').slice(2, 18);
  };

  ªredefine = function(obj, name, value, kind) {
    switch (kind) {
      case 'constant':
        return Object.defineProperty(obj, name, {
          value: value,
          enumerable: true
        });
      case 'private':
        return Object.defineProperty(obj, name, {
          value: value,
          enumerable: false
        });
    }
  };

  Main = (function() {
    Main.prototype.C = ªC;

    Main.prototype.toString = function() {
      return "[object " + this.C + "]";
    };

    function Main(config) {
      var $preset, error, i, k, len, ref, v;
      if (config == null) {
        config = {};
      }
      for (k in config) {
        v = config[k];
        this[k] = v;
      }
      this.ookonsole = null;
      this.oo3d = null;
      this.$$presets = null;
      this.focus = void 0;
      if (this.$cssTarget) {
        injectCSS(this.$cssTarget, "Injected by " + ªC + " " + ªV);
      }
      if (this.$htmlTarget) {
        injectHTML(this.$htmlTarget, "Injected by " + ªC + " " + ªV);
      }
      this.$$presets = $$('.magnubbin-presets >li');
      ref = this.$$presets;
      for (i = 0, len = ref.length; i < len; i++) {
        $preset = ref[i];
        $preset.addEventListener('click', (function(_this) {
          return function(event) {
            return _this.ookonsole.execute(event.target.getAttribute('data-command'));
          };
        })(this));
      }
      try {
        this.ookonsole = new Ookonsole({
          $display: $('#ookonsole-display'),
          $command: $('#ookonsole-command'),
          context: this
        });
        this.initTasks();
        this.ookonsole.show();
        this.ookonsole.start();
        this.oo3d = new Oo3d({
          $main: $('#oo3d-main')
        });
        this.oo3d.render();
      } catch (_error) {
        error = _error;
        $('#magnubbin-error').innerHTML = error;
        $('#magnubbin-error').className = '';
      }
    }

    Main.prototype.initTasks = function() {
      this.ookonsole.addTask('add', {
        summary: "Add a new magnubbin to the scene",
        completions: ['add ocrex', 'add slyce', 'add betr'],
        details: "add\n---\n@todo describe. \n\n@todo usage\n",
        runner: function(context, options) {
          var index, oo3d;
          oo3d = context.oo3d;
          switch (options[0]) {
            case 'ocrex':
              index = oo3d.addBuffer({
                positions: [-2.0, 0.3, -1.84, 2.0, 0.3, -1.84, 0.0, 0.0, 2.742566667, 0.0, 0.0, 2.742566667, 0.0, 2.2678, 0.77866667, -2.0, 0.3, -1.84, -2.0, 0.3, -1.84, 0.0, 2.2678, 0.77866667, 2.0, 0.3, -1.84, 2.0, 0.3, -1.84, 0.0, 2.2678, 0.77866667, 0.0, 0.0, 2.742566667],
                colors: [1.0, 0.0, 0.0, 1.0, 1.0, 0.0, 1.0, 1.0, 1.0, 0.0, 0.5, 1.0, 1.0, 0.0, 0.0, 1.0, 1.0, 0.0, 1.0, 1.0, 1.0, 0.0, 0.5, 1.0, 1.0, 0.0, 0.0, 1.0, 1.0, 0.0, 1.0, 1.0, 1.0, 0.0, 0.5, 1.0, 1.0, 0.0, 0.0, 1.0, 1.0, 0.0, 1.0, 1.0, 1.0, 0.0, 0.5, 1.0]
              });
              context.focus = index;
              oo3d.render();
              return "Added slyce. Focused on index " + index;
            case 'slyce':
              index = oo3d.addBuffer({
                positions: [0.0, 0.3, 1.0, -0.4, -0.5, 1.0, 0.8, -0.3, 1.0],
                colors: [1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 1.0]
              });
              context.focus = index;
              oo3d.render();
              return "Added slyce. Focused on index " + index;
            case 'betr':
              index = oo3d.addBuffer({
                positions: [1.0, 0.3, -1.0, -0.4, -0.5, 0.0, 0.8, 0.3, -1.0],
                colors: [1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 1.0]
              });
              context.focus = index;
              oo3d.render();
              return "Added betr. Focused on index " + index;
            default:
              return "'" + options[0] + "' not recognised";
          }
        }
      });
      this.ookonsole.addTask('focus', {
        summary: "Focus on one of the magnubbins",
        completions: ['focus '],
        details: "focus\n-----\n@todo describe. \n\n@todo usage\n",
        runner: function(context, options) {
          var index, target;
          index = options[0];
          if (!/^\d+$/.test(index)) {
            return "'" + index + "' is not a valid index - must be an integer";
          } else if (!(target = context.oo3d.buffers[+index])) {
            return "Index '" + index + "' does not exist";
          } else {
            context.focus = +index;
            return "Focused on index '" + index + "'";
          }
        }
      });
      this.ookonsole.addTask('blur', {
        summary: "Focus on the camera",
        completions: ['blur'],
        details: "blur\n-----\n@todo describe. \n\n@todo usage\n",
        runner: function(context, options) {
          context.focus = void 0;
          return "Focused on the camera";
        }
      });
      this.ookonsole.addTask('move', {
        summary: "Move the Focused magnubbin",
        completions: ['move ', 'move x ', 'move y ', 'move z '],
        details: "move\n----\n@todo describe. \n\n@todo usage\n",
        runner: function(context, options) {
          var axis, distance;
          axis = options[0];
          distance = options[1];
          if (!/^[xyz]$/.test(axis)) {
            return "Axis " + axis + " is not valid - use x, y, or z";
          } else if (!/^-?\d+(.\d+)?$/.test(distance)) {
            return "Distance " + distance + " is not valid - must be numeric";
          } else {
            if ('x' === axis) {
              context.oo3d.translate(+distance, 0, 0, context.focus);
            }
            if ('y' === axis) {
              context.oo3d.translate(0, +distance, 0, context.focus);
            }
            if ('z' === axis) {
              context.oo3d.translate(0, 0, +distance, context.focus);
            }
            context.oo3d.render();
            if (ªN === ªtype(context.focus)) {
              return "Moved index '" + context.focus + "'";
            } else {
              return "Moved the camera";
            }
          }
        }
      });
      this.ookonsole.addTask('scale', {
        summary: "Scale the Focused magnubbin",
        completions: ['scale ', 'scale 2.0', 'scale 0.5'],
        details: "scale\n----\n@todo describe. \n\n@todo usage\n",
        runner: function(context, options) {
          var factor;
          factor = options[0];
          if (!/^-?\d+(.\d+)?$/.test(factor)) {
            return "Factor " + factor + " is not valid - must be numeric";
          } else {
            context.oo3d.scale(+factor, +factor, +factor, context.focus);
            context.oo3d.render();
            if (ªN === ªtype(context.focus)) {
              return "Scaled index '" + context.focus + "'";
            } else {
              return "Scaled the camera";
            }
          }
        }
      });
      this.ookonsole.addTask('flip', {
        summary: "Flip the Focused magnubbin",
        completions: ['flip ', 'flip 2.0', 'flip 0.5'],
        details: "flip\n----\n@todo describe. \n\n@todo usage\n",
        runner: function(context, options) {
          var axis;
          axis = options[0];
          if (!/^[xyz]$/.test(axis)) {
            return "Axis " + axis + " is not valid - use x, y, or z";
          } else {
            if ('x' === axis) {
              context.oo3d.scale(-1, 1, 1, context.focus);
            }
            if ('y' === axis) {
              context.oo3d.scale(1, -1, 1, context.focus);
            }
            if ('z' === axis) {
              context.oo3d.scale(1, 1, -1, context.focus);
            }
            context.oo3d.render();
            if (ªN === ªtype(context.focus)) {
              return "Flipped index '" + context.focus + "'";
            } else {
              return "Flipped the camera";
            }
          }
        }
      });
      return this.ookonsole.addTask('rotate', {
        summary: "Rotate the Focused magnubbin",
        completions: ['rotate ', 'rotate x ', 'rotate y ', 'rotate z '],
        details: "rotate\n----\n@todo describe. \n\n@todo usage\n",
        runner: function(context, options) {
          var axis, degrees, rads;
          axis = options[0];
          degrees = options[1];
          if (!/^[xyz]$/.test(axis)) {
            return "Axis " + axis + " is not valid - use x, y, or z";
          } else if (!/^-?\d+(.\d+)?$/.test(degrees)) {
            return "Degrees " + degrees + " is not valid - must be numeric";
          } else {
            rads = degrees * Math.PI / 180;
            if ('x' === axis) {
              context.oo3d.rotate(rads, 0, 0, context.focus);
            }
            if ('y' === axis) {
              context.oo3d.rotate(0, rads, 0, context.focus);
            }
            if ('z' === axis) {
              context.oo3d.rotate(0, 0, rads, context.focus);
            }
            context.oo3d.render();
            if (ªN === ªtype(context.focus)) {
              return "Rotated index '" + context.focus + "' " + degrees + "º on axis " + axis;
            } else {
              return "Rotated the camera " + degrees + "º on axis " + axis;
            }
          }
        }
      });
    };

    Main.prototype.yy = function(xx) {};

    return Main;

  })();

  injectCSS = function($cssTarget, title) {
    return $cssTarget.innerHTML = "/* `@import` must go first */\n@import url(http://fonts.googleapis.com/css?family=Podkova);\n\n" + $cssTarget.innerHTML + "\n\n/* " + title + " */\n\n\n/* MAIN SECTIONS */\n.magnubbin-main {\n  color: #acb;\n}\n.magnubbin-main >* {\n  position: absolute;\n  box-sizing: border-box;\n  top:    0;\n  bottom: 0;\n  padding: 1rem;\n}\n.magnubbin-view {\n  left:   0;\n  right:  0;\n  background: rgba(30,50,40,0.7);\n}\n.magnubbin-control {\n  display: flex;\n  flex-direction: column;\n  justify-content: flex-end;\n  right:  0;\n  width:  25%;\n  height: 100%;\n  min-width: 35rem; /* usual maximum ookonsole-display lines */\n  background: rgba(30,30,30,0.7);\n}\n.magnubbin-control >* {\n  flex-basis: 0%; /* log is '100%', so expands to fill */\n}\n.magnubbin-control h4 { /* @todo remove if not used */\n  margin: 0;\n  padding: 0.3em 0;\n}\n.magnubbin-control ul,\n.magnubbin-control pre {\n  margin-top: 0.5em;\n}\n.magnubbin-main a {\n  color: #eee;\n  text-decoration: none;\n  transition: all 0.5s;\n}\n.magnubbin-main a:hover {\n  color: #0f3;\n}\n\n\n/* 3D CONTEXT */\n#oo3d-main {\n  position: absolute;\n  top:     0;\n  left:    0;\n  width:   100%;\n  height:  100%;\n  z-index: -1;\n}\n\n\n/* INFO PANEL */\n.magnubbin-preexisting {\n  left:   -76%;\n  width:  75%;\n  background: rgba(10,10,10,0);\n  transition: all 1s;\n}\n.magnubbin-preexisting.active {\n  left:   0;\n  background: rgba(10,10,10,1);\n}\n\n\n/* TOGGLE */\n.magnubbin-toggle-preexisting {\n  display: block;\n  height: 3em;\n  margin: 0 0 0.3em 0;\n}\n.magnubbin-icon-info {\n  display: block;\n  float: left;\n  margin: -0.2em 0 0.2em 0;\n  padding: 0;\n  width:      1em;\n  height:     1em;\n  max-width:  1em;\n  max-height: 1em;\n  border: 2px solid; /* same as text color */\n  border-radius: 2em;\n  font: bold italic 2em serif;\n}\n.magnubbin-icon-info:before {\n  content: \"i\";\n  display: inline-block;\n  margin-left: 0.35em;\n}\n.magnubbin-logo {\n  font: bold 1.5em Podkova;\n}\n.magnubbin-control .magnubbin-logo {\n  float: right;\n}\n\n\n/* PRESETS */\nul.magnubbin-presets {\n  clear: both;\n  margin: 0 0 0.2em 0;\n  padding: 0;\n}\n.magnubbin-presets >li {\n  display: inline-block;\n  padding: 0.5em 0.8em;\n  margin: 0 0.2em 0.5em 0;\n  list-style-type: none;\n  border: 2px solid;\n  border-radius: 0.2em;\n  color: #eee;\n  cursor: pointer;\n  transition: all 0.5s;\n}\n.magnubbin-presets >li:hover {\n  color: #0f3;\n}\n\n\n/* DISPLAY AND COMMAND */\n.magnubbin-control #ookonsole-display {\n  flex-basis: 100%; /* override 1px */\n  margin: 0;\n  padding: 0.75em 0.8em;\n  border: 2px solid;\n  border-radius: 0.4em 0.4em 0 0;\n  font: 0.75rem \"monaco\", monospace;\n}\n#ookonsole-command {\n  display: block;\n  box-sizing: border-box;\n  padding: 0.5em;\n  width: 100%;\n  border: 2px solid #acb;\n  border-radius: 0 0 0.4em 0.4em;\n  font: 1em \"monaco\", monospace;\n  color: #eee;\n  background: transparent;\n}\n\n\n/* ERROR */\n#magnubbin-error {\n  position: absolute;\n  box-sizing: border-box;\n  bottom:  0;\n  left:    5%;\n  width:  90%;\n  padding: 1rem;\n  font-family: monaco, monospace;\n  background-color: #933;\n  color: #fff;\n  transition: all 0.5s;\n  opacity: 1;\n}\n#magnubbin-error.hidden {\n  padding-bottom: 0;\n  opacity: 0;\n}\n";
  };

  injectHTML = function($htmlTarget, title) {
    $htmlTarget.className += ' magnubbin-wrap';
    $htmlTarget.innerHTML = "\n\n\n<!-- " + title + " -->\n\n<!-- The main Magnubbin elements -->\n<main class=\"magnubbin-main\">\n  <section class=\"magnubbin-view\">\n    <canvas id=\"oo3d-main\" width=\"600\" height=\"450\"></canvas><!-- @todo resize with window -->\n    <a href=\"http://loop.coop/\" title=\"Created by Loop.Coop\" class=\"magnubbin-logo\">Loop.Coop</a>\n    <div id=\"magnubbin-error\" class=\"hidden\"></div>\n  </section>\n  <section class=\"magnubbin-control\">\n    <a href=\"#/\" title=\"Toggle info\" class=\"magnubbin-toggle-preexisting\">\n      <span class=\"magnubbin-icon-info\"></span>\n      <span class=\"magnubbin-logo\">Magnubbin</span>\n    </a>\n    <ul class=\"magnubbin-presets\">\n      <li data-command=\"clear\">Clear</li>\n      <li data-command=\"add ocrex\">Add Ocrex</li>\n      <li data-command=\"add slyce\">Add Slyce</li>\n      <li data-command=\"add betr\">Add Betr</li>\n    </ul>\n    <ul class=\"magnubbin-presets\">\n      <li data-command=\"move x -0.2\">x-</li>\n      <li data-command=\"move x 0.2\" >x+</li>\n      <li data-command=\"move y -0.2\">y-</li>\n      <li data-command=\"move y 0.2\" >y+</li>\n      <li data-command=\"move z -0.2\">z-</li>\n      <li data-command=\"move z 0.2\" >z+</li>\n    </ul>\n    <ul class=\"magnubbin-presets\">\n      <li data-command=\"rotate x -20\">rx-</li>\n      <li data-command=\"rotate x 20\" >rx+</li>\n      <li data-command=\"rotate y -20\">ry-</li>\n      <li data-command=\"rotate y 20\" >ry+</li>\n      <li data-command=\"rotate z -20\">rz-</li>\n      <li data-command=\"rotate z 20\" >rz+</li>\n    </ul>\n    <ul class=\"magnubbin-presets\">\n      <li data-command=\"blur\">Focus Camera</li>\n      <li data-command=\"focus 0\">0</li>\n      <li data-command=\"focus 1\">1</li>\n      <li data-command=\"focus 2\">2</li>\n      <li data-command=\"focus 3\">3</li>\n      <li data-command=\"focus 4\">4</li>\n    </ul>\n    <pre id=\"ookonsole-display\"></pre>\n    <div><input id=\"ookonsole-command\"></div>\n  </section>\n  <section class=\"magnubbin-preexisting\">\n    " + $htmlTarget.innerHTML + "\n  </section>\n</main>\n";
    return $('.magnubbin-toggle-preexisting').addEventListener('click', function() {
      var $preexisting;
      $preexisting = $('.magnubbin-preexisting');
      if (/active/.test($preexisting.className)) {
        return $preexisting.className = 'magnubbin-preexisting';
      } else {
        return $preexisting.className = 'magnubbin-preexisting active';
      }
    });
  };

  if (ªF === typeof define && define.amd) {
    define(function() {
      return Main;
    });
  } else if (ªO === typeof module && module && module.exports) {
    module.exports = Main;
  } else {
    this[ªC] = Main;
  }

  if (ªF === typeof define && define.amd) {

  } else if (ªO === typeof module && module && module.exports) {
    Ookonsole = require('ookonsole');
  } else if (this.Ookonsole) {
    Ookonsole = this.Ookonsole;
  } else {
    Ookonsole = window.Ookonsole;
  }

  if ((ªU !== typeof arts) && (ªU !== typeof resolvers) && (ªU !== typeof updaters)) {
    main = new Main({
      $cssTarget: $('style'),
      $htmlTarget: $('article')
    });
  }

}).call(this);

//// End injecting plugins. 


//// Run each updater when the page loads, and when the URL hash changes. 
onHashchange();
window.addEventListener('hashchange', onHashchange);


}).call(this, document) });

  </script>

</head>
<body>

  <article id="apage_readme"
        class="apage"
  data-apage-opath="/README.md"
  data-apage-dname="_"
  data-apage-order="-1"
  data-apage-front='[]'
  data-apage-title="Magnubbin">
  <h1>Magnubbin</h1>
  <h4>A super-rapid 3D prototyping system</h4>
  <ul>
  <li><a href="">Homepage</a></li>
  <li><a href="#/doc/documentation">Documentation</a></li>
  <li><a href="test/run-test.html">Test</a></li>
  <li><a href="https://github.com/loopdotcoop/magnubbin">Fork Magnubbin on GitHub</a></li>
  </ul>
  
  </article><!-- / #apage_readme -->


  <article id="apage_doc_documentation"
        class="apage"
  data-apage-opath="/doc/00-documentation.md"
  data-apage-dname="_doc_"
  data-apage-order="0"
  data-apage-front='[]'
  data-apage-title="Documentation">
  <h1>Documentation</h1>
  <ul>
  <li><a href="#/">Home</a></li>
  </ul>
  
  </article><!-- / #apage_doc_documentation -->


  <!-- ‘Inspect Element’ here, for Apage’s injected elements -->

</body>
</html>